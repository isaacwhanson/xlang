/* Coco/R ATG for (C#) XLang Compiler */
using System.Collections;

COMPILER XLang
public _XLang xlang;

CHARACTERS
  lower       = 'a'..'z'.
  upper       = 'A'..'Z'.
  letter      = lower + upper + '_'.
  newline     = '\r' + '\n'.
  whitespace  = ' ' + '\t' + '\u000b' + '\u000c' + '\f'.
  bin         = "01".
  oct         = '0'..'7'.
  digit       = '0'..'9'.
  nonzero     = '1'..'9'.
  hex         = digit + 'a'..'f' + 'A'..'F'.
  notquote    = ANY - '\"' - newline.
  notapost    = ANY - '\'' - newline.
  sign        = "+-".
  e           = "eE".

TOKENS
  ident       = letter {letter | digit}.
  string      = '"' {notquote | "\\\""} '"'.
  char        = '\'' (notapost | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\u" hex hex hex hex) '\''.
  float       = (digit {digit} '.' digit {digit} [e [sign] digit {digit}] | digit {digit} e [sign] digit {digit}) ['f'|'l'|'F'|'L'].
  int         = (nonzero {digit} | '0' ['o'|'O'] {oct} | ("0x"|"0X") hex {hex} | ("0b"|"0B") bin {bin}) {'u'|'U'|'l'|'L'}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO "\n"
COMMENTS FROM "#" TO "\n"
IGNORE whitespace + newline

PRODUCTIONS
  XLang =                                   (. xlang = new _XLang(t); .)
    Module<out _Module module>              (. xlang.module = module; .).

  Module<out _Module module> =              (. module = new _Module(t); .)
     GlblStmt<out IStmt stmt0>              (. module.stmts.Add(stmt0); .)
    {GlblStmt<out IStmt stmt1>              (. module.stmts.Add(stmt1); .)}.

  GlblStmt<out IStmt stmt> = SYNC
    (LetStmt<out _LetStmt let_stmt>         (. stmt = let_stmt; .)) SYNC ";".

  LetStmt<out _LetStmt let_stmt> =
    "let" Ident<out _Ident id>
    "=" Expr<out IExpr expr>                (. let_stmt = new _LetStmt(t){ id=id, expr=expr }; .).

  Expr<out IExpr expr> =
    CondExpr<out IExpr lhs>                 (. expr = lhs; .).

  CondExpr<out IExpr expr> =
    LogOrExpr<out IExpr lhs>                (. expr = lhs; .)
    ['?' Expr<out IExpr consequent>
     ':' Expr<out IExpr alternative>        (. expr = new _CondExpr(t) { condition=expr, consequent=consequent, alternative=alternative }; .)].

  LogOrExpr<out IExpr expr> =
    LogXorExpr<out IExpr lhs>               (. expr = lhs; .)
    {"||" LogXorExpr<out IExpr rhs>         (. expr = new _LogOrExpr(t) { left=expr, right=rhs }; .)}.

  LogXorExpr<out IExpr expr> =
    LogAndExpr<out IExpr lhs>               (. expr = lhs; .)
    {"^^" LogAndExpr<out IExpr rhs>         (. expr = new _LogXorExpr(t) { left=expr, right=rhs }; .)}.

  LogAndExpr<out IExpr expr> =
    OrExpr<out IExpr lhs>                   (. expr = lhs; .)
    {"&&" OrExpr<out IExpr rhs>             (. expr = new _LogAndExpr(t) { left=expr, right=rhs }; .)}.

  OrExpr<out IExpr expr> =
    XorExpr<out IExpr lhs>                  (. expr = lhs; .)
    {'|' XorExpr<out IExpr rhs>             (. expr = new _OrExpr(t) { left=expr, right=rhs }; .)}.

  XorExpr<out IExpr expr> =
    AndExpr<out IExpr lhs>                  (. expr = lhs; .)
    {'^' AndExpr<out IExpr rhs>             (. expr = new _XorExpr(t) { left=expr, right=rhs }; .)}.

  AndExpr<out IExpr expr> =
    EqlExpr<out IExpr lhs>                  (. expr = lhs; .)
    {'&' EqlExpr<out IExpr rhs>             (. expr = new _AndExpr(t) { left=expr, right=rhs }; .)}.

  EqlExpr<out IExpr expr> =
    RelExpr<out IExpr lhs>                  (. expr = lhs; .)
                                           {(. EqlOp op; .)
    ( "=="                                  (. op = EqlOp.EQUAL; .)
    | "!="                                  (. op = EqlOp.NOTEQUAL; .)
    | "==="                                 (. op = EqlOp.HARDEQUAL; .)
    | "!=="                                 (. op = EqlOp.HARDNOTEQUAL; .))
    RelExpr<out IExpr rhs>                  (. expr = new _EqlExpr(t) { left=expr, op=op, right=rhs }; .)}.

  RelExpr<out IExpr expr> =
    ShiftExpr<out IExpr lhs>                (. expr = lhs; .)
                                           {(. RelOp op; .)
    ( '<'                                   (. op = RelOp.LESSTHAN; .)
    | '>'                                   (. op = RelOp.GREATERTHAN; .)
    | "<="                                  (. op = RelOp.LESSTHANEQUAL; .)
    | ">="                                  (. op = RelOp.GREATERTHANEQUAL; .))
    ShiftExpr<out IExpr rhs>                (. expr = new _RelExpr(t) { left=expr, op=op, right=rhs }; .)}.

  ShiftExpr<out IExpr expr> =
    AddExpr<out IExpr lhs>                  (. expr = lhs; .)
                                           {(. ShiftOp op; .)
    ( "<<"                                  (. op = ShiftOp.LEFT; .)
    | ">>"                                  (. op = ShiftOp.RIGHT; .))
    AddExpr<out IExpr rhs>                  (. expr = new _ShiftExpr(t) { left=expr, op=op, right=rhs }; .)}.

  AddExpr<out IExpr expr> =
    MultExpr<out IExpr lhs>                 (. expr = lhs; .)
                                           {(. AddOp op; .)
    ( '+'                                   (. op = AddOp.PLUS; .)
    | '-'                                   (. op = AddOp.MINUS; .))
    MultExpr<out IExpr rhs>                 (. expr = new _AddExpr(t) { left=expr, op=op, right=rhs }; .)}.

  MultExpr<out IExpr expr> =
    UnaryExpr<out IExpr lhs>                (. expr = lhs; .)
                                           {(. MultOp op; .)
    ( '*'                                   (. op = MultOp.TIMES; .)
    | '/'                                   (. op = MultOp.DIVIDE; .)
    | '%'                                   (. op = MultOp.MODULO; .))
    UnaryExpr<out IExpr rhs>                (. expr = new _MultExpr(t) { left=expr, op=op, right=rhs }; .)}.

  UnaryExpr<out IExpr expr> =               (. expr = null; .)
    (Primary<out IExpr lhs>                 (. expr = lhs; .)
                                           |(. UnaryOp op; .)
    (('-'                                   (. op = UnaryOp.NEGATE; .)
    | '~'                                   (. op = UnaryOp.COMPLIMENT; .)
    | '!'                                   (. op = UnaryOp.NOT; .))
    UnaryExpr<out IExpr lhs>                (. expr = new _UnaryExpr(t) { op=op, left=lhs }; .))).

  Primary<out IExpr expr> =                 (. expr = null; .)
    (Ident<out _Ident lhs>                  (. expr = lhs; .)
    | String<out _String lhs>               (. expr = lhs; .)
    | Char<out _Char lhs>                   (. expr = lhs; .)
    | Float<out _Float lhs>                 (. expr = lhs; .)
    | Int<out _Int lhs>                     (. expr = lhs; .)
    | '(' Expr<out IExpr lhs> WEAK ')'      (. expr = lhs; .)).

  Ident<out _Ident expr> = ident            (. expr = new _Ident(t); .).
  String<out _String expr> = string         (. expr = new _String(t); .).
  Char<out _Char expr> = char               (. expr = new _Char(t); .).
  Int<out _Int expr> = int                  (. expr = new _Int(t); .).
  Float<out _Float expr> = float            (. expr = new _Float(t); .).

END XLang.
