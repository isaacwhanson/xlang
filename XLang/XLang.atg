COMPILER XLang

CHARACTERS
  lower       = 'a'..'z' + '_'.
  upper       = 'A'..'Z'.
  letter      = lower + upper.
  newline     = '\r' + '\n'.
  whitespace  = ' ' + '\t' + '\u000b' + '\u000c' + '\f'.
  bin         = "01".
  oct         = '0'..'7'.
  digit       = '0'..'9'.
  nonzero     = '1'..'9'.
  hex         = digit + 'a'..'f' + 'A'..'F'.
  notquote    = ANY - '\"' - newline.
  notapost    = ANY - '\'' - newline.
  sign        = "+-".
  e           = "eE".

TOKENS
  identifier  = lower {letter | digit}.
  type        = upper {letter | digit}.
  string      = '"' {notquote | "\\\""} '"'.
  character   = '\'' (notapost | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\u" hex hex hex hex) '\''.
  float       = (digit {digit} '.' digit {digit} [e [sign] digit {digit}] | digit {digit} e [sign] digit {digit}) ['f'|'l'|'F'|'L'].
  integer     = (nonzero {digit} | '0' ['o'|'O'] {oct} | ("0x"|"0X") hex {hex} | ("0b"|"0B") bin {bin}) {'u'|'U'|'l'|'L'}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO "\n"
COMMENTS FROM "#" TO "\n"
IGNORE whitespace + newline

PRODUCTIONS
  XLang =                                   (. ast = new _XLang(t);.)
    Module<out _Module module>              (. ast.module = module;.).

  Module<out _Module module> =              (. module = new _Module(t);.)
     GlblStmt<out IStmt stmt0>              (. module.stmts.Add(stmt0);.)
    {GlblStmt<out IStmt stmt1>              (. module.stmts.Add(stmt1);.)}.

  GlblStmt<out IStmt stmt> = SYNC
    (LetStmt<out _LetStmt let_stmt>         (. stmt = let_stmt;.)) SYNC ";".

  StmtBlock<out _StmtBlock stmt> =
    "{"                                     (. stmt = new _StmtBlock(t);.)
    {Stmt<out IStmt stmt0>                  (. stmt.stmts.Add(stmt0);.)}
    "}".

  Stmt<out IStmt stmt> =                    (. stmt = null;.)
    ( StmtBlock<out _StmtBlock block>       (. stmt = block;.)
    | RetStmt<out _RetStmt ret>             (. stmt = ret;.)
    | BreakStmt<out _BreakStmt brk>         (. stmt = brk;.)
    | ContStmt<out _ContStmt cont>          (. stmt = cont;.)
    | WhileStmt<out _WhileStmt whil>        (. stmt = whil;.)) ";".

  WhileStmt<out _WhileStmt stmt> =
    "while"
    "(" Expr<out IExpr expr>
    ")" Stmt<out IStmt stmt0>               (. stmt = new _WhileStmt(token) { expr = expr, stmt = stmt0 };.).

  BreakStmt<out _BreakStmt stmt> =
    "break"                                 (. stmt = new _BreakStmt(t);.).

  ContStmt<out _ContStmt stmt> =
    "continue"                              (. stmt = new _ContStmt(t);.).

  RetStmt<out _RetStmt stmt> =
    "return"                                (. stmt = new _RetStmt(t);.)
    [Expr<out IExpr expr>                   (. stmt.expr = expr;.)].

  LetStmt<out _LetStmt let_stmt> =
    "let"                                   (. let_stmt = null;.)
    Type<out _Type typ> Ident<out _Ident ident>
    (ParamDeclList<out _ParamDeclList plist> "=>" Stmt<out IStmt stmt>
                                            (. let_stmt = new _LetStmt(token) { ident = ident, plist = plist, stmt = stmt };.)
    | "=" Expr<out IExpr expr>              (. let_stmt = new _LetStmt(token) { ident = ident, expr = expr };.)).

  ParamDecl<out _ParamDecl param> =
    Type<out _Type typ0>
    Ident<out _Ident ident0>                (. param = new _ParamDecl(token) { type = typ0, ident = ident0 };.).

  ParamDeclList<out _ParamDeclList list> =
    "("                                     (. list = new _ParamDeclList(t);.)
    [ParamDecl<out _ParamDecl p0>           (. list.plist.Add(p0);.)
    {"," ParamDecl<out _ParamDecl p1>       (. list.plist.Add(p1);.)}]
    ")".

  Expr<out IExpr expr> =
    CondExpr<out IExpr lhs>                 (. expr = lhs;.).

  CondExpr<out IExpr expr> =
    LogOrExpr<out IExpr lhs>                (. expr = lhs;.)
    ['?'                                    (. token = t;.)
     Expr<out IExpr consequent>
     ':' Expr<out IExpr alternative>        (. expr = new _CondExpr(token) { condition = expr, consequent = consequent, alternative = alternative };.)].

  LogOrExpr<out IExpr expr> =
    LogXorExpr<out IExpr lhs>               (. expr = lhs;.)
    {"||"                                   (. token = t;.)
    LogXorExpr<out IExpr rhs>               (. expr = new _LogOrExpr(token) { left = expr, right = rhs };.)}.

  LogXorExpr<out IExpr expr> =
    LogAndExpr<out IExpr lhs>               (. expr = lhs;.)
    {"^^"                                   (. token = t;.)
    LogAndExpr<out IExpr rhs>               (. expr = new _LogXorExpr(token) { left = expr, right = rhs };.)}.

  LogAndExpr<out IExpr expr> =
    OrExpr<out IExpr lhs>                   (. expr = lhs;.)
    {"&&"                                   (. token = t;.)
    OrExpr<out IExpr rhs>                   (. expr = new _LogAndExpr(token) { left = expr, right = rhs };.)}.

  OrExpr<out IExpr expr> =
    XorExpr<out IExpr lhs>                  (. expr = lhs;.)
    {'|'                                    (. token = t;.)
    XorExpr<out IExpr rhs>                  (. expr = new _OrExpr(token) { left = expr, right = rhs };.)}.

  XorExpr<out IExpr expr> =
    AndExpr<out IExpr lhs>                  (. expr = lhs;.)
    {'^'                                    (. token = t;.)
    AndExpr<out IExpr rhs>                  (. expr = new _XorExpr(token) { left = expr, right = rhs };.)}.

  AndExpr<out IExpr expr> =
    EqlExpr<out IExpr lhs>                  (. expr = lhs;.)
    {'&'                                    (. token = t;.)
    EqlExpr<out IExpr rhs>                  (. expr = new _AndExpr(token) { left = expr, right = rhs };.)}.

  EqlExpr<out IExpr expr> =
    RelExpr<out IExpr lhs>                  (. expr = lhs;.)
                                           {(. EqlOp op; token = la;.)
    ( "=="                                  (. op = EqlOp.EQUAL;.)
    | "!="                                  (. op = EqlOp.NOTEQUAL;.)
    | "==="                                 (. op = EqlOp.HARDEQUAL;.)
    | "!=="                                 (. op = EqlOp.HARDNOTEQUAL;.))
    RelExpr<out IExpr rhs>                  (. expr = new _EqlExpr(token) { op = op, left = expr, right = rhs };.)}.

  RelExpr<out IExpr expr> =
    ShiftExpr<out IExpr lhs>                (. expr = lhs;.)
                                           {(. RelOp op; token = la;.)
    ( '<'                                   (. op = RelOp.LESSTHAN;.)
    | '>'                                   (. op = RelOp.GREATERTHAN;.)
    | "<="                                  (. op = RelOp.LESSTHANEQUAL;.)
    | ">="                                  (. op = RelOp.GREATERTHANEQUAL;.))
    ShiftExpr<out IExpr rhs>                (. expr = new _RelExpr(token) { op = op, left = expr, right = rhs };.)}.

  ShiftExpr<out IExpr expr> =
    AddExpr<out IExpr lhs>                  (. expr = lhs;.)
                                           {(. ShiftOp op; token = la;.)
    ( "<<"                                  (. op = ShiftOp.LEFT;.)
    | ">>"                                  (. op = ShiftOp.RIGHT;.))
    AddExpr<out IExpr rhs>                  (. expr = new _ShiftExpr(token) { op = op, left = expr, right = rhs };.)}.

  AddExpr<out IExpr expr> =
    MultExpr<out IExpr lhs>                 (. expr = lhs;.)
                                           {(. AddOp op; token = la;.)
    ( '+'                                   (. op = AddOp.PLUS;.)
    | '-'                                   (. op = AddOp.MINUS;.))
    MultExpr<out IExpr rhs>                 (. expr = new _AddExpr(token) { op = op, left = expr, right = rhs };.)}.

  MultExpr<out IExpr expr> =
    UnaryExpr<out IExpr lhs>                (. expr = lhs;.)
                                           {(. MultOp op; token = la;.)
    ( '*'                                   (. op = MultOp.TIMES;.)
    | '/'                                   (. op = MultOp.DIVIDE;.)
    | '%'                                   (. op = MultOp.MODULO;.))
    UnaryExpr<out IExpr rhs>                (. expr = new _MultExpr(token) { op = op, left = expr, right = rhs };.)}.

  UnaryExpr<out IExpr expr> =               (. expr = null;.)
    (Primitive<out IExpr lhs>               (. expr = lhs;.)
                                           |(. UnaryOp op; token = la;.)
    (('-'                                   (. op = UnaryOp.NEGATE;.)
    | '~'                                   (. op = UnaryOp.COMPLIMENT;.)
    | '!'                                   (. op = UnaryOp.NOT;.))
    UnaryExpr<out IExpr lhs>                (. expr = new _UnaryExpr(token) { op = op, left = lhs };.))).

  Primitive<out IExpr expr> =               (. expr = null;.)
    ( Ident<out _Ident lhs>                 (. expr = lhs;.)
    | String<out _String lhs>               (. expr = lhs;.)
    | Char<out _Char lhs>                   (. expr = lhs;.)
    | Float<out _Float lhs>                 (. expr = lhs;.)
    | Int<out _Int lhs>                     (. expr = lhs;.)
    | Boolean<out _Boolean lhs>             (. expr = lhs;.)
    | Type<out _Type lhs>                   (. expr = lhs;.)
    | Array<out _Array lhs>                 (. expr = lhs;.)
    | '(' Expr<out IExpr lhs> WEAK ')'      (. expr = lhs;.)).

  Ident<out _Ident term> = identifier       (. term = new _Ident(t);.).
  String<out _String term> = string         (. term = new _String(t);.).
  Char<out _Char term> = character          (. term = new _Char(t);.).
  Int<out _Int term> = integer              (. term = new _Int(t);.).
  Float<out _Float term> = float            (. term = new _Float(t);.).
  Type<out _Type term> = type               (. term = new _Type(t);.).
  Boolean<out _Boolean term> =
    ("true" | "false")                      (. term = new _Boolean(t);.).

  Array<out _Array expr> =                   
    '['                                     (. expr = new _Array(t);.)
    [Expr<out IExpr exp0>                   (. expr.exprs.Add(exp0);.)
    {',' Expr<out IExpr exp1>               (. expr.exprs.Add(exp1);.)}]
    ']'.

END XLang.
